import dayjs from "dayjs";
import { getDatabase, ref, set, query, get, orderByChild, equalTo } from "firebase/database";
import { NETWORK_TYPES } from "./DentalAPI";
import flattenJSONResponse from "./Utils";

/** API to handle interactions with the firebase database. Specifically with regards to write-transactions. */
class DatabaseAPI {
  /// Private helper Methods
  /// ======================

  /**
   * Returns the service details of a specific service name along with the index it was found at.
   *
   * @param {array} responseData pVerify Response Data (cached, in flattened format), to search through for the specific service details.
   * @param {string} serviceName Service Name of the service details to extract.
   * @returns Object containing { ServiceName, EligibilityDetails, ServiceDetailInd } or { ServiceDetailInd: -1 } if no valid service detail was found
   */
  static _getServiceDetails(responseData, serviceName) {
    const { ServiceDetails } = responseData || [];
    const serviceDetailInd = ServiceDetails.findIndex((v) => v.ServiceName === serviceName);
    // no index found ? return { ServiceDetailInd: -1 }
    if (!serviceDetailInd) {
      return { ServiceDetailInd: serviceDetailInd };
    }

    //  { ServiceName, EligibilityDetails, ServiceDetailInd }
    return { ...ServiceDetails[serviceDetailInd], ServiceDetailInd: serviceDetailInd };
  }

  /**
   * Finds remaining/limitations for a given eligibility/service/benefit and updates the appropriate remaining/limitations/usage field and returns resulting, updated list back.
   *
   * @param {string} ServiceName The extracted ServiceName object using {@link DentalAPI._getServiceDetails}
   * @param {string} EligibilityDetails The current eligibility details list we want to update.
   * @param {string} networkType The network type to update.
   * @param {int} amount The amount we want to update with.
   * @returns EligibilityDetails with updated corresponding remaining/limitations/usage field.
   */
  static _getUpdatedEligibilityDetailsForNetwork(ServiceName, EligibilityDetails, networkType, amount) {
    let newEligibilityDetails = [...EligibilityDetails];

    // attempt to find remaining ind
    const foundRemainingInd = EligibilityDetails.findIndex(
      (v) =>
        v.PlanCoverageDescription === networkType &&
        v.EligibilityOrBenefit === "Limitations" &&
        v.TimePeriodQualifier === "Remaining"
    );
    // attempt to find limitations ind (not remaining)
    const foundLimitationsInd = EligibilityDetails.findIndex(
      (v) =>
        v.PlanCoverageDescription === networkType &&
        v.EligibilityOrBenefit === "Limitations" &&
        v.TimePeriodQualifier !== "Remaining"
    );

    let max = 0;
    let qualifier = "";
    if (foundLimitationsInd >= 0) {
      // if we found limitations, define max and qualifier
      const Limitations = EligibilityDetails[foundLimitationsInd];
      if (Limitations.HealthCareServiceDeliveries) {
        const limits = Limitations.HealthCareServiceDeliveries[0] || {};
        max = limits.TotalQuantity || 0;
        qualifier = limits.QuantityQualifier;
      }
    }
    if (foundRemainingInd >= 0) {
      // if we found remaining, use max/qualifier to assign updates according to amount
      const Remaining = EligibilityDetails[foundRemainingInd];
      // handle update
      const newUsageInfoObject = {
        ...Remaining,
        QuantityAmount: max > 0 ? Math.max(0, Math.min(amount, max)) : amount,
        QuantityQualifier: qualifier,
      };
      newEligibilityDetails[foundRemainingInd] = newUsageInfoObject; // replace in list
    } else {
      // otherwise create new usage object and append to fields
      const newUsageInfoObject = {
        EligibilityOrBenefit: "Limitations",
        PlanCoverageDescription: networkType,
        PlanNetworkIndicator: "Yes",
        Procedure: ServiceName,
        TimePeriodQualifier: "Remaining",
        QuantityAmount: max > 0 ? Math.max(0, Math.min(amount, max)) : amount,
        QuantityQualifier: qualifier,
      };
      newEligibilityDetails.push(newUsageInfoObject); // push to list
    }

    // return updated eligibility details (separate from input list)
    return newEligibilityDetails;
  }

  /**
   * Handles updating eligibility details in the database itself.
   *
   * @param {string} officeID office id to use for determining the location in db to update.
   * @param {string} patientKey patient key to use for determining location in db to update.
   * @param {string} responseKey response key to use for determining location in db to update.
   * @param {string} serviceDetailInd service detail ind (generated by {@link DentalAPI._getServiceDetails]}
   * @param {array} eligibilityDetails Eligibility Details to use to update the DB with.
   * @returns Result Promise which should return true is success, false otherwise.
   */
  static _updateEligibilityDetails(officeID, patientKey, responseKey, serviceDetailInd, eligibilityDetails) {
    const db = getDatabase();
    const responseEligibilityDetailsRef = ref(
      db,
      `data/${officeID}/patients_data/${patientKey}/${responseKey}/ServiceDetails/${serviceDetailInd}/EligibilityDetails`
    );
    return set(responseEligibilityDetailsRef, eligibilityDetails)
      .then((res) => {
        return true;
      })
      .catch((err) => {
        console.error("Error updating database", err);
        return false;
      });
  }

  /**
   * Updates cached usage info for a specific benefit and network type.
   *
   * @param {array} responseData The response data generated by pVerify, flattened and cached in database.
   * @param {string} officeID Office ID for update location in database.
   * @param {string} patientKey Patient key to use for determining location in db to update.
   * @param {string} responseKey Response key to use for determining location in db to update.
   * @param {string} serviceName Name/key of the service/benefit we are trying to update.
   * @param {string} networkType Network type to update service/benefit for.
   * @param {int} amount Amount to update with.
   */
  static async updateUsageRow(responseData, officeID, patientKey, responseKey, serviceName, networkType, amount) {
    // trying to extract service details
    const { ServiceName, EligibilityDetails, ServiceDetailInd } = DatabaseAPI._getServiceDetails(
      responseData,
      serviceName
    );
    if (ServiceDetailInd === -1) {
      return;
    }

    // get update eligibility details for network type and amount
    let newEligibilityDetails = DatabaseAPI._getUpdatedEligibilityDetailsForNetwork(
      ServiceName,
      EligibilityDetails,
      networkType,
      amount
    );

    // update DB
    return DatabaseAPI._updateEligibilityDetails(
      officeID,
      patientKey,
      responseKey,
      ServiceDetailInd,
      newEligibilityDetails
    );
  }

  /**
   * Updates cached usage info for all network types of a benefit.
   *
   * @param {array} responseData The response data generated by pVerify, flattened and cached in database.
   * @param {string} officeID Office ID for update location in database.
   * @param {string} patientKey Patient key to use for determining location in db to update.
   * @param {string} responseKey Response key to use for determining location in db to update.
   * @param {string} serviceName Name/key of the service/benefit we are trying to update.
   * @param {object} row Row from table containing keys corresponding to network types containing values to update with.
   * @param {int} valueOverride Value override to use if we want to update everything to one value regardless of row values.
   */
  static async updateUsageRowAllNetworks(
    responseData,
    officeID,
    patientKey,
    responseKey,
    serviceName,
    row,
    valueOverride = null
  ) {
    // trying to extract service details
    const { ServiceName, EligibilityDetails, ServiceDetailInd } = DatabaseAPI._getServiceDetails(
      responseData,
      serviceName
    );
    if (ServiceDetailInd === -1) {
      return;
    }

    let newEligibilityDetails = [...EligibilityDetails];
    // for each network type, try getting updated eligibility details (compounded)
    for (let networkType of NETWORK_TYPES) {
      const nt_key = networkType.toLowerCase().replaceAll(" ", "_");
      const amount = valueOverride !== null ? valueOverride : row[nt_key];
      // use newEligibilityDetails as EligibilityDetails in the helper method, so we can effectively concat previous changes!
      newEligibilityDetails = DatabaseAPI._getUpdatedEligibilityDetailsForNetwork(
        ServiceName,
        newEligibilityDetails,
        networkType,
        amount
      );
    }

    // update DB
    return DatabaseAPI._updateEligibilityDetails(
      officeID,
      patientKey,
      responseKey,
      ServiceDetailInd,
      newEligibilityDetails
    );
  }

  /**
   * Helper function to handle updating the database after getting an eligibility response.
   *
   * @param {object} requestData Request Data used to create the response data.
   * @param {object} responseData Response data from the API.
   * @return Result promise which returns True if all updates succeed, false otherwise.
   */
  static async updateDatabaseWithEligibilityResponse(officeID, requestData, responseData) {
    const patientID =
      `${requestData.SubscriberMemberId}_${requestData.SubscriberFirstName}_${requestData.SubscriberLastName}`.toLowerCase();

    const db = getDatabase();
    // const refMeta = ref(db, `data/${officeID}/meta`);
    const refPatientsList = ref(db, `data/${officeID}/patients/${patientID}`);
    const refPatientsData = ref(db, `data/${officeID}/patients_data/${patientID}/${responseData.RequestID}`);

    // always flatten response before inserting into database
    const flatResponseData = await flattenJSONResponse(responseData);

    // // update meta
    // set(refMeta, {
    //   name: requestData.ProviderName,
    //   npi: requestData.ProviderNpi,
    //   taxid: requestData.ProviderTaxId,
    // });

    // update patients meta info
    const updatePatientsList = set(refPatientsList, {
      lastRequestTime: dayjs().valueOf(),
      lastRequestID: responseData.RequestID,
      patientFirstName: requestData.SubscriberFirstName,
      patientLastName: requestData.SubscriberLastName,
      patientName: `${requestData.SubscriberFirstName} ${requestData.SubscriberLastName}`,
      patientDOB: requestData.SubscriberDob,
      patientMemberID: requestData.SubscriberMemberId,
    });

    // update patients request data
    const patientData = { ...flatResponseData, timestamp: dayjs().valueOf() };
    const updatePatientsData = set(refPatientsData, patientData);

    return Promise.all([updatePatientsList, updatePatientsData])
      .then(() => {
        return true;
      })
      .catch((error) => {
        console.error("Error updating database with API response data!", error);
        return false;
      });
  }

  /**
   * Helper function to attempt retrieving an existing eligibility response from the database.
   *
   * @param {object} requestData Request data being used to potentially call the API.
   * @returns Existing response object value if found.
   */
  static async tryGetExistingResponseFromDatabase(officeID, requestData) {
    const patientID =
      `${requestData.SubscriberMemberId}_${requestData.SubscriberFirstName}_${requestData.SubscriberLastName}`.toLowerCase();

    const db = getDatabase();
    const existingRef = query(
      ref(db, `data/${officeID}/patients_data/${patientID}`),
      orderByChild("PverifyPayerCode"),
      equalTo(requestData.PayerCode)
    );
    const existingSnap = await get(existingRef);
    const existingResponse = existingSnap && existingSnap.val();
    const key = existingResponse && Object.keys(existingResponse) && Object.keys(existingResponse)[0];

    // at this point, we might as well check if request fields from Data match up in the entry that was found. No point in sending back a stale transaction for an old verification that has vastly different request parameters.
    return existingResponse && existingResponse[key];
  }
}

export default DatabaseAPI;
